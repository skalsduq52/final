ajax (asynchronous JavaScript And XML)
서버와 통신하기 위해 XMLHttpRequest 객체를 사용하는 것
JSON, XML, HTML 그리고 일반 텍스트 형식 등을 포함한 다양한 포맷
을 주고 받을 수 있는 비동기 통신 방식

json = {키,값} 
         [값1,값2] 대괄호는 배열
         [{키,값}, {키2,값2}] 도 가능
--------------------------------------------------------------------------------------------------------------------

statmentType = PREPARED | STATEMENT| CALLABLE

1) 쿼리 문장 분석
2) 컴파일
3) 실행

Statement는 매번 새로 실행하고 prepared는 캐시에 담아 재사용

--------------------------------------------------------------------------------------------------------------------
서비스 로깅 처리용 AOP
ALL - 모든 로깅.
TRACE - 추적 레벨로 DEBUG보다 상세한 정보
DEBUG - 디버깅
INFO - 각종 정보.
WARN - 경고
ERROR - 오류
FATAL - 심각한 오류
OFF - 로깅 해제.

--------------------------------------------------------------------------------------------------------------------
%m: 로그 내용 출력
%p: debug, info, warn, error, fatal 등의 priority 출력
%r: 어플이 시작 후 이벤트가 발생하는 시점까지의 경과시간 밀리세컨드로 출력
%c: package 출력
%c{n}: n(숫자) 만큼의 package를 가장 하단 부터 역으로 출력
예) %c{2} 일때 a.b.c 는 b.c 로 출력된다.
%n: 개행문자 출력. 플렛폼에 따라 \r\n 또는 \n 출력.
%d: 이벤트 발생 날짜 출력 ( 프로그램의 실행속도를 느리게 한다.)
예) %d{HH:mm:ss} 또는 %d{dd MMMM yyyy HH:mm:ss}
%C: 호출자의 클래스명 출력
예) %C{2} 일때 a.b.c.TestClass 는 c.TestClass 로 출력된다.
%M: method 이름.
%F: 프로그램 파일명.
%l: caller의 정보
%L: caller의 라인수
%x: thread와 관련된 NDC(nested diagnostic context)
%X: thread와 관련된 MDC(mapped diagnostic context)
%%: % 표시를 출력
%t: 쓰레드 이름

--------------------------------------------------------------------------------------------------------------------
시험

405 - 메소드가 없음  (get, post)
교재 168쪽

--------------------------------------------------------------------------------------------------------------------
서블릿컨텍스트 안에 베이스 패키지 수정
--------------------------------------------------------------------------------------------------------------------
input[name="nu1"].val()
--------------------------------------------------------------------------------------------------------------------

IOC = Inversion of Control
프로그램이 시작되는 지점에서 사용할 객체를 생성하고 만들어진 객체를
통해 메소드를 호출하는 작업을 통해 프로그램이 수행된다.
객체의 생성부터 생명주기의 관리까지 !모든 객체에 대한 제어 권한을
다른 대상에게 위임한 것! 이 제어권의 역행(IOC) 이라는 개념이다.

- 작업을 수행하는 쪽에서 객체를 생성하는 기존의 제어 흐름 개념을 뒤집은 것이다
- 사용할 객체를 직접 생성하거나 선택하지 않는다
- 모든 객체는 제어 권한을 위임받는 특별한 객체에 의해서 만들어 지고 사용된다
- 객체는 자신이 어떻게 생성되고 어떻게 사용되는지 알 수 없다

--------------------------------------------------------------------------------------------------------------------

maven 메이븐
스프링 프로젝트를 사용하기 위해서는 다양한 라이브러리 파일들을 설치하고 관리해야 하는데,
Maven은 이러한 라이브러리들을 통합해서 관리해 주는 플러그인 실행 프레임워크이다.
기존에 lib 폴더 내에 사용하고자 하는 라이브러리를 등록해서 사용했다면, Maven은 이를 자
동으로 관리해 주기 때문에 라이브러리를 이용하는데 더욱 편리함을 느낄 수 있다

Maven의 5가지 특징
Plugin 			Maven에서 제공하는 모든 기능은 Plugin기반으로 동작한다
LifeCycle			Maven은 일련의 단계를 통한 빌드 순서를 가진다
Dependency 		<dependencies>/<dependency> 엘리먼트를 사용하여 의존성을 관리
Profile 			서로 다른 환경에 따라 달라지는 설정을 관리하는 기능
POM(Project Object Model)	하나의 프로젝트당 pom.xml을 하나씩 가짐으로써 프로젝트 자체와 의
			존성에 대한 설정을 포함한다

--------------------------------------------------------------------------------------------------------------------

JDBCTempate 클래스
java의 jdbc 프로그램의 반복적인 코딩을 Template Method pattern을 이용해서 
더쉽고 편하게 사용할 수 있게 해주는 클래스

@어노테이션 Controller, Service, Repository, Component

스프링 2.5 이전 버전에서는 모든 빈 객체가 XML파일에 수동으로 설정되어야 했으며, 자바
에 대한 어노테이션 지원이 없었다. 때문에 XML 코딩에 손이 많이 가게 되었으며, 유지보수에서도
문제가 발생했다. 이를 2.5 버전 이후로는 특정 어노테이션에 대한 XML 설정을 자동으로 해줌으로
써, XML설정 파일을 더욱 간편화 시켜 주었다.
Spring에서 제공하는 Controller, Service, Repository, Component 어노테이션을 사용하게 되면 자동
으로 bean 객체가 등록된다. 이렇게 자동 의존성 주입이 된 객체를 사용하려면 반드시
@Autowired 어노테이션을 레퍼런스 변수를 선언한 라인 바로 위에 표시해야 한다.
각각의 어노테이션의 특징을 정리하면 다음과 같다.

@Controller spring 		! MVC의 Controller 객체임을 명시, 
			스프링 설정 파일에 <context:component-scan>을 자동 등록 !

@Service 			비즈니스 로직을 담당하는 Service 객체임을 명시
			@Service("OO")에 등록된 OO과 변수명이 같아야 한다.

@Repository 		데이터의 접근을 담당하는 DAO 객체임을 명시
			@Repository("OO")에 등록된 OO과 변수명이 같아야 한다.

@Component 		! <context:component-scan>을 정의하고 적용할 기본 패키지를 base-package 
			속성으로 등록, @Scope를 사용하여 범위 지정이 가능하다 !
 
컴포넌트 둘중 하나 쓰면됨 	! 클래스를 자동으로 인스턴스화 해서 스프링 관리 풀에 정하고 @Autowired 					annotation을 이용해 의존성 주입을 할 수 있게 해주는 annotation !


--------------------------------------------------------------------------------------------------------------------


스프링 MVC의 구성요소

DispatcherServlet		! 클라이언트의 요청을 전달받음
			요청에 맞는 컨트롤러가 리턴한 결과값을 View에 전달하여 알맞은 응답을
			생성 !
HandlerMapping 		! 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할지 결정 !

Controller 		클라이언트의 요청을 처리한 뒤, 결과를 DispatcherServlet에게 리턴
ModelAndView		 컨트롤러가 처리한 결과 정보 및 뷰 선택에 필요한 정보를 담음
ViewResolver 		! 컨트롤러의 처리 결과를 생성할 뷰를 결정 !
View			! 컨트롤러의 처리 결과 화면을 생성, JSP나 Velocity 템플릿 파일 등을 뷰로 사용 !
--------------------------------------------------------------------------------------------------------------------

.어노테이션 관련 설정
DispatcherServlet 에 <annotation-driven /> 등록 확인함.
그 다음 Controller 클래스가 검색 범위에 포함되도록 하고자 <context:componentscan> 엘리먼트의 base-package 속성에 Controller 클래스들이 있는 가장 상위 패키지를 등록한다.
<context:component-scan base-package=”com.kh.hello/**/controller” />
또는
<context:component-scan base-package=”com.kh.hello” />

스프링 컨테이너가 시작 될 때, base-package에 지정한 패키지의 하부 패키지에서
@Component, @Service, @Repository 등의 bean을 검색해 등록해주는 xml 셋팅

--------------------------------------------------------------------------------------------------------------------
@ResposeBody
  @Controller 메서드에서 클라이언트의 요청을 처리한 후, forward or redirect를 통해 페이지를
이동하며 view page 코드로 응답하는데, 값 자체를 return하게 만들 때 사용하며 주로 JSON 값을 return
할 때 사용한다.
--------------------------------------------------------------------------------------------------------------------
AOP 용어 정리
Aspect 		- 여러 객체에 공통으로 적용되는 기능을 분리하여 작성한 클래스
		- 로깅, 트랜잭션, 보안 등을 대표적 예로 들 수 있다
Joinpoint 		- 클래스의 객체(인스턴스) 생성 지점, 메소드 호출 시점, 예외 발생 시점 등 특
		정 작업이 시작되는 시점을 말한다
		- Advice 를 적용할 수 있는 시점이다
Advice		 - Joinpoint에 삽입되어 동작될 코드, 메소드를 말한다
		- 동작 시점에 따라 5가지 로 나뉜다
		Before advice Joinpoint 앞에서 실행
		Around Advice Joinpoint 앞과 뒤에서 실행
		After Advice Joinpoint 호출이 리턴되기 직전에 실행
		After Returning Advice Joinpoint 메소드 호출이 정상적으로 종료된 후에 실행
		After Throwing Advice 예외가 발생했을 때 실행

Pointcut		 - 조인 포인트의 부분 집합을 의미
		- 실제 Advice가 적용되는 Joinpoint를 말한다
		- 정규 표현식이나 AspectJ 문법을 이용하여 범위를 정의할 수 있다.

Weaving		 - 작성한 Advice (공통 코드)를 핵심 로직 코드에 삽입하는 것을 말한다
		- 시점에 따라 컴파일 시, 클래스 로딩 시, 런 타임 시에 위빙하는 방식이 있다

--------------------------------------------------------------------------------------------------------------------
POJO(plain old Java objects)
클래스의 상속이나 오버라이딩 등 복잡한 기술을 사용하지 말고, 순수하고 평범한 자바클래스를 바탕으로
웹을 하자는 의도를 담고 있다. 실제 POJO를 지향하는 스프링은 extends, implements 등 문법을 사용하지 않으며,
클래스 의존도를 걱정하지 않아도 된다.
--------------------------------------------------------------------------------------------------------------------
Transactional 어노테이션을 통한 Transaction 제어
root-context.xml에서 <tx:annotation-driven/>을 선언하고, ! 트랜잭션 제어가 필요한 클래스나 메소
드 위에 @Transactional 어노테이션을 표시하여 제어한다 
자동으로 commit, rollback을 관리해준다. !
--------------------------------------------------------------------------------------------------------------------
CORS(Cross Origin Resource Sharing)
클라이언트 측에서 현재 위치하는 도메인이 아닌 다른 도메인에 자원을 요청하면
Same Origin Policy에 위배되어 요청이 거부되는데 이 때 서버측에서 CORS 설정을 해주면, 다른
도메인 이지만 자원 할당을 허가한다.
Spring framework에서는 @CroosOrigin 어노테이션으로 설정 할 수 있다.
 
--------------------------------------------------------------------------------------------------------------------
Around aop int, boolean  프리미티브 타입 리턴일경우 Object를 리턴해줘야 에러 안남.

--------------------------------------------------------------------------------------------------------------------

@Scheduled(fixedRate=1000) = 1초마다 실행시키기
서블릿 컨텍스트에 <task:annotation-driven /> 등록해줘서 @스케듈 어노테이션 활성화 하기.
위에 스키마랑 xmlns 도 등록해줘야 함
